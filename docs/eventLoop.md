# 浏览器事件循环(Event Loop)
:::tip
处理单线程语言JavaScript异步操作的逻辑，叫事件循环。
:::

### 1. 一些概念

在JavaScript中，任务被分为两种，一种叫**宏任务（MacroTask）**，一种叫**微任务（MicroTask）**。

### MacroTask(宏任务）
* script全部代码
* setTimeout
* setInterval
* setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）
* I/O、UI Rendering

### MicroTask（微任务）
* Process.nextTick（Node独有）
* Promise
* Object.observe(废弃)
* MutationObserver [具体使用方式查看这里](http://javascript.ruanyifeng.com/dom/mutationobserver.html)

### JavaScript引擎(举个例子: chrome v8)
JavaScript引擎又称JavaScript解释器，是把JavaScript解释为机器码的工具，分别运行在Node和浏览器中。

### 在Node和浏览器中，事件循环是不一样的。
根据上下文的不同，**Event loop**也有不同的实现：其中**Node**使用了**libuv**库来实现**Event loop**; 而在浏览器中，html规范定义了**Event loop**，具体的实现则交给不同的厂商去完成。

### 异步任务
由于JavaScript是**单线程语言**，所以如果出现堵塞情况，页面可能会有很长时间的停滞情况，然而不是因为**CPU**算不过来，**CPU**反而大部分时间都是空闲的，原因是因为**I/O设备**太慢了(例如: AJAX请求、监听的事件) 所以为了防止堵塞把一些一时半会处理不了的任务挂起等待，接着执行下面的代码，这种被挂起等待的代码块称为**异步任务**。

### I/O
> 计算机中配置的外围设备，根据工作方式不同还分为


* 人机交互设备 — 键盘、显示器、打印机等
* 外部存储器 — 磁盘、磁带、光盘
* 网络通信设备 — 网卡、调制解调器

### 任务队列(task queue)
**任务队列**可以理解为存储**微任务/回调**的队列，I/O设备完成任务后，把**微任务/回调**放到**任务队列**，然后按照先进先出的顺序把**微任务/回调**读到**调用栈**。一个事件循环里有很多个来自不同任务源的**任务队列**。但是因为浏览器自己调度的关系，不同队列的任务的执行顺序是不确定的。

### 调用栈(call stack)
**调用栈**也可以叫执行栈，JS调用栈采用的是后进先出的规则，当函数将要执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。

### 2.事件循环的流程
1. 先MacroTask任务栈取出一个MacroTask。
2. 主线程执行一些同步代码，并把同步任务存进**调用栈**，等待主线程执行。调用webAPI,异步任务被挂起，等到I/O设备完成任务后，把**微任务/回调**存进**任务队列**。
3. 主线程执行完调用栈里的同步任务后(此时调用栈清空)，然后把任务队列里的**微任务/回调**读到**调用栈**，并一次过执行完所有**微任务/回调**。
4. 然后再取一个MacroTask， 然后再来一轮新的循环。


<img :src="$withBase('/event_loop.png')">

